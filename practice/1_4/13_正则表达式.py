# 正则表达式

# 正则表达式由普通字符和元字符组成
# 普通字符包含大小写字母，数字
# 元字符：元字符才是正则表达式的灵魂

# 字符组
# 1. 字符组
# 字符组很简单用[]括起来. 在[]中出现的内容会被匹配. 例如:[abc] 匹配a或b或c      
# 如果字符组中的内容过多还可以使用- ,  例如: [a-z] 匹配a到z之间的所有字母 [0-9]匹配所有阿拉伯数字
# 思考: [a-zA-Z0-9]匹配的是什么?
# 2. 基本元字符
# 基本的元字符. 这个东西网上一搜一大堆. 但是常用的就那么几个:

# .   匹配除换行符以外的任意字符
# \w  匹配字母或数字或下划线
# \s  匹配任意的空白符
# \d  匹配数字
# \n  匹配一个换行符
# \t  匹配一个制表符

# ^   匹配字符串的开始
# $   匹配字符串的结尾

# \W  匹配非字母或数字或下划线
# \D  匹配非数字
# \S  匹配非空白符
# a|b 匹配字符a或字符b
# ()  匹配括号内的表达式，也表示一个组
# [...]   匹配字符组中的任意字符
# [^...]  匹配除了字符组中字符的所有字符


# 3. 量词
# 我们到目前匹配的所有内容都是单一文字符号. 那如何一次性匹配很多个字符呢, 我们要用到量词
# 注意: 量词控制前面的元字符出现的次数

# *   重复零次或更多次
# +   重复一次或更多次  至少有一次
# ?   重复零次或一次
# {n}     重复n次
# {n,}    重复n次或更多次
# {n,m}   重复n到m次


# 4. 惰性匹配和贪婪匹配
# 在量词中的?,*, +,{} 都属于贪婪匹配. 就是尽可能多的匹配到结果

# str: 玩儿吃鸡游戏, 晚上一起上游戏, 干嘛呢? 打游戏啊
# reg: 玩儿.*游戏
#
# 此时匹配的是: 玩儿吃鸡游戏, 晚上一起上游戏, 干嘛呢? 打游戏

# 在使用.*后面如果加了? 则是尽可能的少匹配. 表示惰性匹配
# str: 玩儿吃鸡游戏, 晚上一起上游戏, 干嘛呢? 打游戏啊
# reg: 玩儿.*?游戏

# 此时匹配的是: 玩儿吃鸡游戏

# str: <div>胡辣汤</div>
# reg:<.*>
# 结果:<div>胡辣汤</div>


# str: <div>胡辣汤</div>
# reg:<.*?>
# 结果:<div></div>

# str:<div>胡辣汤</div><span>饭团</span>
# reg:<div>.*?</div>
# 结果:
# <div>胡辣汤</div>




# 5. 分组
# 在正则中使用()进行分组. 比如. 我们要匹配一个相对复杂的身份证号.
# 身份证号分成两种. 老的身份证号有15位.
# 新的身份证号有18位. 并且新的身份证号结尾有可能是x.
































